pattern CVE-2018-20992-MIR

exam {
    #[derive(Default)]
    pub struct Wrapper {
        buf: Vec<u8>,
    }

    fn main() {
        let mut wrapped: Wrapper = Wrapper::default();
        let b = wrapped.buf.len();
        let slice = unsafe {
            std::slice::from_raw_parts_mut(wrapped.buf.as_mut_ptr().offset(b as isize), wrapped.buf.capacity() - b)
            // it violates the precondition of `std::slice::from_raw_parts_mut` to create a slice from uninitialized data
        };
    }
}

patt {
    use alloc::vec::Vec;

    p_slice_from_raw_parts[
        $T: ty = ...,
        $vec: place(Vec<$T>),
    ] = #[mir] pub fn _ (..) -> _ {
        let $src_ref_1: &alloc::vec::Vec<$T> = &$src;
        #[export(len)]
        let $len: usize = alloc::vec::Vec::len(move $src_ref_1); // _2
        let $src_ref_2: &mut alloc::vec::Vec<$T> = &mut $src; // _7
        #[export(ptr)]
        let $ptr: *mut $T = alloc::vec::Vec::as_mut_ptr(move $src_ref_2); // _6
        let $len_1: isize = copy $len as isize (IntToInt); // _8
        let $ptr_1: *mut $T = mut_ptr::offset(move $ptr, move $len_1); // _5
        let $src_ref_3: &alloc::vec::Vec<$T> = &$src; // _11
        let $capacity: usize = alloc::vec::Vec::capacity(move $src_ref_3); // _10
        let $slice_len: usize = Sub(move $capacity, copy $len); // _9

        #[export(slice)]
        let $slice: &mut [$T] = core::slice::from_raw_parts_mut::<'_, u8>(move $ptr_1, move $slice_len); // _4
    }
}
