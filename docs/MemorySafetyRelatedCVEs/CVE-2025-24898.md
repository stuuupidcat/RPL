# CVE-2025-24898

## Metadata

- RustSec: \_
- Mitre: https://www.cve.org/CVERecord?id=CVE-2025-24898
- Bug Fix GitHub Commit/PR: <https://github.com/sfackler/rust-openssl/pull/2360/>

## Description / Analysis

> `SSL_select_next_proto()` is a helper function used to select protocols.
>
> `server` and `server_len` contain the server's list of supported protocols, and `client` and `client_len` contain the client's list of supported protocols. The lists are in the format used by the ALPN extension.
>
> The first item in the `server`, `server_len` list that matches an item in the `client`, `client_len` list is selected, and returned in `out`, `outlen`. **The `out` value will point into either server or client, so it should be copied immediately**.
>
> The `client` list must include at least one valid (nonempty) protocol entry in the list.

_See <https://manpages.debian.org/experimental/libssl-doc/SSL_select_next_proto.3ssl.en.html> for details._

```C
int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
                          const unsigned char *server,
                          unsigned int server_len,
                          const unsigned char *client,
                          unsigned int client_len);
```

Implementation of `select_next_proto` before the fix:

```rust
/// A standard implementation of protocol selection for Application Layer Protocol Negotiation
/// (ALPN).
///
/// `server` should contain the server's list of supported protocols and `client` the client's. They
/// must both be in the ALPN wire format. See the documentation for
/// [`SslContextBuilder::set_alpn_protos`] for details.
///
/// It will select the first protocol supported by the server which is also supported by the client.
///
/// [`SslContextBuilder::set_alpn_protos`]: struct.SslContextBuilder.html#method.set_alpn_protos
#[corresponds(SSL_select_next_proto)]
pub fn select_next_proto<'a>(server: &[u8], client: &'a [u8]) -> Option<&'a [u8]> {
    unsafe {
        let mut out = ptr::null_mut();
        let mut outlen = 0;
        let r = ffi::SSL_select_next_proto(
            &mut out,
            &mut outlen,
            server.as_ptr(),
            server.len() as c_uint,
            client.as_ptr(),
            client.len() as c_uint,
        );
        if r == ffi::OPENSSL_NPN_NEGOTIATED {
            Some(util::from_raw_parts(out as *const u8, outlen as usize))
        } else {
            None
        }
    }
}
```

However, as the comment in the function states, the `out` value will point into either `server` or `client`, so in Rust, `out` should be viewed as a borrow to either `server` or `client`, and `out` should outlive both `server` and `client`. This is not guaranteed in the current implementation, as the `server` has an implicit arbitrary lifetime, which is not related to the lifetime `'a` of `out`.

# Fix

```diff
/// A standard implementation of protocol selection for Application Layer Protocol Negotiation
/// (ALPN).
///
/// `server` should contain the server's list of supported protocols and `client` the client's. They
/// must both be in the ALPN wire format. See the documentation for
/// [`SslContextBuilder::set_alpn_protos`] for details.
///
/// It will select the first protocol supported by the server which is also supported by the client.
///
/// [`SslContextBuilder::set_alpn_protos`]: struct.SslContextBuilder.html#method.set_alpn_protos
#[corresponds(SSL_select_next_proto)]
- pub fn select_next_proto<'a>(server: &[u8], client: &'a [u8]) -> Option<&'a [u8]> {
+ pub fn select_next_proto<'a>(server: &'a [u8], client: &'a [u8]) -> Option<&'a [u8]> {
    unsafe {
        let mut out = ptr::null_mut();
        let mut outlen = 0;
        let r = ffi::SSL_select_next_proto(
            &mut out,
            &mut outlen,
            server.as_ptr(),
            server.len() as c_uint,
            client.as_ptr(),
            client.len() as c_uint,
        );
        if r == ffi::OPENSSL_NPN_NEGOTIATED {
            Some(util::from_raw_parts(out as *const u8, outlen as usize))
        } else {
            None
        }
    }
}
```

```Rust
#[server_buffer: slice(server, server_len)]
#[client_buffer: slice(server, server_len)]
#[out_buffer: slice(*out, *outlen)]
#[server_buffer and client_buffer outlives out_buffer]
fn SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
                         const unsigned char *server,
                         unsigned int server_len,
                         const unsigned char *client,
                         unsigned int client_len) -> c_int;
```
